/**
 * Copyright 2014-2015 Alexander Debus
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */


#pragma once

#include "types.h"
#include "math/Vector.hpp"
#include "dimensions/DataSpace.hpp"
#include "fields/background/templates/TWTS/numComponents.hpp"

namespace picongpu
{
namespace templates
{
namespace twts
{
/** Auxiliary functions for calculating the TWTS field */
namespace detail
{
    /** Calculate the SI position vectors that later enter the Ex(r, t), By(r, t)
     *  and Bz(r ,t) calculations as r.
     *  \param cellIdx The total cell id counted from the start at timestep 0. */
    HDINLINE PMacc::math::Vector<floatD_64,numComponents>
    getFieldPositions_SI(const DataSpace<simDim>& cellIdx,
                         const DataSpace<simDim>& halfSimSize,
                         const PMacc::math::Vector<floatD_X, numComponents>& fieldOnGridPositions,
                         const float_64 unit_length,
                         const float_64 focus_y_SI,
                         const float_X phi,
                         const bool phiPositive = true )
    {
        /* Note: Neither direct precisionCast on picongpu::cellSize
           or casting on floatD_ does work. */
        const floatD_64 cellDim(picongpu::cellSize);
        const floatD_64 cellDimensions = cellDim * unit_length;
        
        /* TWTS laser coordinate origin is centered transversally and defined longitudinally by
           the laser center in y (usually maximum of intensity). */
        floatD_X laserOrigin = precisionCast<float_X>(halfSimSize);
        laserOrigin.y() = float_X( focus_y_SI/cellDimensions.y() );
        
        /* For the Yee-Cell shifted fields, obtain the fractional cell index components and add
         * that to the total cell indices. The physical field coordinate origin is transversally
         * centered with respect to the global simulation volume.
         * PMacc::math::Vector<floatD_X, numComponents> fieldPositions = 
         *                fieldSolver::NumericalCellType::getEFieldPosition(); */
        PMacc::math::Vector<floatD_X, numComponents> fieldPositions;// = fieldOnGridPositions;
        
        PMacc::math::Vector<floatD_64,numComponents> fieldPositions_SI;
        PMacc::math::Vector<floatD_64,numComponents> correctionTermOnGridPositions_SI =
            precisionCast<floatD_64>(fieldOnGridPositions) * cellDimensions;
        
        for( uint32_t i = 0; i < numComponents; ++i ) /* cellIdx Ex, Ey and Ez */
        {
            fieldPositions[i]    = ( precisionCast<float_X>(cellIdx) - laserOrigin );
            fieldPositions_SI[i] = precisionCast<float_64>(fieldPositions[i]) * cellDimensions;

            fieldPositions_SI[i] = rotateField(fieldPositions_SI[i],phi);

            /* Only relevant for the phi<0 case.
             * The phi<0 case is generated by inverting the y-axis in
             * TWTS laser reference coordinates (hence the rotation), but
             * before adding the discrete intra-cell offsets (in TWTS reference coordinates).
             */
            if (!phiPositive)
            {
                fieldPositions_SI[i].y() = -fieldPositions_SI[i].y();
                //correctionTermOnGridPositions_SI[i] = floatD_64(2.0)
                //        * rotateField(correctionTermOnGridPositions_SI[i],phi);
                //fieldPositions_SI[i].y() -= correctionTermOnGridPositions_SI[i].y();
            }
            fieldPositions_SI[i] += rotateField(correctionTermOnGridPositions_SI[i],phi);
        }
        
        return fieldPositions_SI;
    }
    
} /* namespace detail */
} /* namespace twts */
} /* namespace templates */
} /* namespace picongpu */
