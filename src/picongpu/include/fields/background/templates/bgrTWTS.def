/**
 * Copyright 2014-2015 Alexander Debus, Axel Huebl
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "types.h"

#include "math/Vector.hpp"
#include "dimensions/DataSpace.hpp"


namespace picongpu
{
    /** Load external TWTS field
     *
     */
    namespace templates
    {
        class TWTSFieldE
        {
        public:
            typedef float_64 float_T;
            
            /* Center of simulation volume in number of cells */
            PMACC_ALIGN(halfSimSize,DataSpace<simDim>);
            /* y-position of TWTS coordinate origin inside the simulation coordinates [meter]
               The other origin coordinates (x and z) default to globally centered values
               with respect to the simulation volume. */
            const PMACC_ALIGN(focus_y_SI,float_64);
            /* Laser wavelength [meter] */
            const PMACC_ALIGN(wavelength_SI,float_64);
            /* TWTS laser pulse duration [second] */
            const PMACC_ALIGN(pulselength_SI,float_64);
            /* line focus height of TWTS pulse [meter] */
            const PMACC_ALIGN(w_x_SI,float_64);
            /* line focus width of TWTS pulse [meter] */
            const PMACC_ALIGN(w_y_SI,float_64);
            /* interaction angle between TWTS laser propagation vector and the y-axis [rad] */
            const PMACC_ALIGN(phi,float_X);
            /* propagation speed of TWTS laser overlap
            normalized to the speed of light. [Default: beta0=1.0] */
            const PMACC_ALIGN(beta_0,float_X);
            /* If auto_tdelay=FALSE, then a user defined delay is used. [second] */
            const PMACC_ALIGN(tdelay_user_SI,float_64);
            /* Make time step constant accessible to device. */
            const PMACC_ALIGN(dt,float_64);
            /* Make length normalization constant accessible to device. */
            const PMACC_ALIGN(unit_length,float_64);
            /* Should the TWTS laser delay be chosen automatically, such that
               the laser gradually enters the simulation volume? [Default: TRUE] */
            const PMACC_ALIGN(auto_tdelay,bool);
            /* Number of field components used in the simulation. [Default: 3 for both 2D and 3D] */
            const static int numComponents=DIM3;
            
            /** Electric field of the electric field in the TW
             *
             * \param focus_y_SI the distance to the laser focus in y-direction [m]
             * \param wavelength_SI central wavelength [m]
             * \param pulselength_SI sigma of std. gauss for intensity (E^2), 
             *  pulselength_SI = FWHM_of_Intensity / 2.35482 [seconds (sigma)]
             * \param w_x beam waist: distance from the axis where the pulse intensity (E^2)
             *  decreases to its 1/e^2-th part at the focus position of the laser [m]
             * \param w_y \see w_x
             * \param phi interaction angle between TWTS laser propagation vector and
             *  the y-axis [rad, default = 90.*(PI/180.)]
             * \param beta_0 propagation speed of overlap normalized to
             *  the speed of light [c, default = 1.0]
             * \param tdelay_user manual time delay if auto_tdelay is false
             * \param auto_tdelay calculate the time delay such that the TWTS pulse is not
             *  inside the simulation volume at simulation start timestep = 0 [default = true]
             */
            HDINLINE
            TWTSFieldE( const float_64 focus_y_SI,
                        const float_64 wavelength_SI,
                        const float_64 pulselength_SI,
                        const float_64 w_x_SI,
                        const float_64 w_y_SI,
                        const float_X phi               = 90.*(PI/180.),
                        const float_X beta_0            = 1.0,
                        const float_64 tdelay_user_SI   = 0.0,
                        const bool auto_tdelay          = true );

            /** Specify your background field E(r,t) here
             *
             * \param cellIdx The total cell id counted from the start at timestep 0.
             * \param currentStep The current time step
             * \return float3_X with field normalized to amplitude in range [-1.:1.]
             */
            HDINLINE float3_X
            operator()( const DataSpace<simDim>& cellIdx,
                        const uint32_t currentStep ) const;

            /** Calculate the Ex(r,t) field here
             *
             * \param pos Spatial position of the target field
             * \param time Absolute time (SI, including all offsets and transformations)
             *  for calculating the field
             * \return Ex-field component of the non-rotated TWTS field in SI units */
            HDINLINE float_T
            calcTWTSEx( const float3_64& pos, const float_64 time ) const;
            
            /** Calculate the SI position vectors that later enter the Ex(r, t) calculations as r.
             * \tparam T_dim Specializes for the simulation dimension
             * \param cellIdx The total cell id counted from the start at timestep 0. */
            template <unsigned T_dim>
            HDINLINE PMacc::math::Vector<float3_64,numComponents>
            getEfieldPositions_SI(const DataSpace<simDim>& cellIdx) const;
            
            /** Calculate the E-field vector of the TWTS laser in SI units.
             * \tparam T_dim Specializes for the simulation dimension
             * \param cellIdx The total cell id counted from the start at timestep 0
             * \return Efield vector of the rotated TWTS field in SI units */
            template <unsigned T_dim>
            HDINLINE float3_X
            getTWTSEfield_Normalized(
                            const PMacc::math::Vector<float3_64,numComponents>& eFieldPositions_SI,
                            const float_64 time) const;
            
            /** Obtain the SI time that later enters the Ex(r, t) calculations as r.
             * \tparam T_dim Specializes for the simulation dimension
             *  \param CurrentStep current time step number of simulation
             *  \return time in SI units */
            template <unsigned T_dim>
            HDINLINE float_64 getTime_SI(const uint32_t currentStep) const;
            
            HDINLINE PMacc::math::Vector<float3_X,numComponents>
            dummyCast(const PMacc::math::Vector<float3_X,numComponents>& x) const;
            HDINLINE PMacc::math::Vector<float3_X,numComponents>
            dummyCast(const PMacc::math::Vector<float2_X,numComponents>& x) const;
            HDINLINE float3_X
            dummyCast(const float3_X& x) const { return x; }
            HDINLINE float3_X
            dummyCast(const float2_X& x) const { return float3_X( x.x(),x.y(),float_X(0.0) ); }
        
        };

        class TWTSFieldB
        {
        public:
            typedef float_64 float_T;
            
            /* Center of simulation volume in number of cells */
            PMACC_ALIGN(halfSimSize,DataSpace<simDim>);
            /* y-position of TWTS coordinate origin inside the simulation coordinates [meter]
               The other origin coordinates (x and z) default to globally centered values
               with respect to the simulation volume. */
            const PMACC_ALIGN(focus_y_SI,float_64);
            /* Laser wavelength [meter] */
            const PMACC_ALIGN(wavelength_SI,float_64);
            /* TWTS laser pulse duration [second] */
            const PMACC_ALIGN(pulselength_SI,float_64);
            /* line focus height of TWTS pulse [meter] */
            const PMACC_ALIGN(w_x_SI,float_64);
            /* line focus width of TWTS pulse [meter] */
            const PMACC_ALIGN(w_y_SI,float_64);
            /* interaction angle between TWTS laser propagation vector and the y-axis [rad] */
            const PMACC_ALIGN(phi,float_X);
            /* propagation speed of TWTS laser overlap
               normalized to the speed of light. [Default: beta0=1.0] */
            const PMACC_ALIGN(beta_0,float_X);
            /* If auto_tdelay=FALSE, then a user defined delay is used. [second] */
            const PMACC_ALIGN(tdelay_user_SI,float_64);
            /* Make time step constant accessible to device. */
            const PMACC_ALIGN(dt,float_64);
            /* Make length normalization constant accessible to device. */
            const PMACC_ALIGN(unit_length,float_64);
            /* Should the TWTS laser delay be chosen automatically, such that
            the laser gradually enters the simulation volume? [Default: TRUE] */
            const PMACC_ALIGN(auto_tdelay,bool);
            /* Number of field components used in the simulation. [Default: 3 for both 2D and 3D] */
            const static int numComponents=DIM3;
            
            HDINLINE
            TWTSFieldB( const float_64 focus_y_SI,
                        const float_64 wavelength_SI,
                        const float_64 pulselength_SI,
                        const float_64 w_x_SI,
                        const float_64 w_y_SI,
                        const float_X phi               = 90.*(PI/180.),
                        const float_X beta_0            = 1.0,
                        const float_64 tdelay_user_SI   = 0.0,
                        const bool auto_tdelay          = true );
            
            
            /** Specify your background field B(r,t) here
             *
             * \param cellIdx The total cell id counted from the start at t=0
             * \param currentStep The current time step */
            HDINLINE float3_X
            operator()( const DataSpace<simDim>& cellIdx,
                        const uint32_t currentStep ) const;

            /** Calculate the By(r,t) field here
             *
             * \param pos Spatial position of the target field.
             * \param time Absolute time (SI, including all offsets and transformations)
             *  for calculating the field */
            HDINLINE float_T
            calcTWTSBy( const float3_64& pos, const float_64 time ) const;

            /** Calculate the Bz(r,t) field here
             *
             * \param pos Spatial position of the target field.
             * \param time Absolute time (SI, including all offsets and transformations)
             *  for calculating the field */
            HDINLINE float_T
            calcTWTSBz( const float3_64& pos, const float_64 time ) const;

            /** Calculate the SI position vectors that later enter
             *  the By(r, t) and Bz(r, t) calculations as r.
             * \tparam T_dim Specializes for the simulation dimension
             * \param cellIdx The total cell id counted from the start at timestep 0. */
            template<unsigned T_dim>
            HDINLINE PMacc::math::Vector<float3_64,numComponents>
            getBfieldPositions_SI(const DataSpace<simDim>& cellIdx) const;
            
            /** Calculate the B-field vector of the TWTS laser in SI units.
             * \tparam T_dim Specializes for the simulation dimension
             * \param cellIdx The total cell id counted from the start at timestep 0
             * \return B-field vector of the rotated TWTS field in SI units */
            template<unsigned T_dim>
            HDINLINE float3_X
            getTWTSBfield_Normalized(
                            const PMacc::math::Vector<float3_64,numComponents>& eFieldPositions_SI,
                            const float_64 time) const;
            
            /** Obtain the SI time that later enters the By(r, t) and Bz(r, t) calculations as r.
             * \tparam T_dim Specializes for the simulation dimension
             *  \param CurrentStep current time step number of simulation
             *  \return time in SI units */
            template<unsigned T_dim>
            HDINLINE float_64 getTime_SI(const uint32_t currentStep) const;

            HDINLINE PMacc::math::Vector<float3_X,numComponents>
            dummyCast(const PMacc::math::Vector<float3_X,numComponents>& x) const;
            HDINLINE PMacc::math::Vector<float3_X,numComponents>
            dummyCast(const PMacc::math::Vector<float2_X,numComponents>& x) const;
            HDINLINE float3_X
            dummyCast(const float3_X& x) const { return x; }
            HDINLINE float3_X
            dummyCast(const float2_X& x) const { return float3_X( x.x(),x.y(),float_X(0.0) ); }
           
        };

    } /* namespace templates */
} /* namespace picongpu */
